<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>My basic understanding of HMC | Kangning Diao</title> <meta name="author" content="Kangning Diao"> <meta name="description" content="Maybe appropriate for physics-background people. Some of examples are imagined by myself and could be wrong."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dkn16.github.io/blog/2023/HMC/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kangning </span>Diao</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">My basic understanding of HMC</h1> <p class="post-meta">September 18, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/sampling"> <i class="fas fa-hashtag fa-sm"></i> sampling</a>     ·   <a href="/blog/category/theories"> <i class="fas fa-tag fa-sm"></i> theories</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The Hamitonian Monte Carlo (HMC) and its variants are almost the best sampling algorithms now, as long as you can get access to the gradient. I’ve learnt it several years ago, but soon forgot. Now I try again, to understand it in a physicist way – though i’m not a physicist.</p> <h2 id="traditional-mcmc">Traditional MCMC</h2> <h3 id="an-analogy-to-statistical-mechanics">An analogy to statistical mechanics</h3> <p>Suppose we want to get the distribution \(V(q)\) of an variable \(q\) (let’s name it in Hamitonian way), one thing we can learn from the statistical physics is that at equilibrium state, a physical system with potential \(U(q)\) converges at \(p(q)\propto \exp^{-U(q)}\) (Assuming kinetic energy is much less than the potential energy in this system and \(\beta=1\)). Then one can easily figure out, the distribution \(V(q)\) is equivalent to the particle distribution in a physical system with potential \(- \log V(q)\) in the equilibrium state. Suppose this state have many particles – their distribution will show us our target distribution.</p> <h3 id="temporal-series-instead-of-ensembles">Temporal series, instead of ensembles</h3> <p>– But how do we get these particles? What we want is the ensemble of single particle. In this ensemble, the probability of particle show up at state \(q\) is \(\exp^{-U(q)}\). Get an ensemble is non-trivial, but back to why we introduce the ensemble, we want to substitude the ensemble average with temporal average, now we can do the opposite: we evolve a particle to get its temporal evolution, which should be identical to an ensemble.</p> <p>Well, as in statistical mechanics, `detailed balance’ can help us to determine the evolution track of a particle. The detailed balance tells us, in the equilibrium, the transition probability from \(q_0\) to \(q_1\) and its inverse follows: \(\begin{equation} p_t(q_0 \rightarrow q_1) p(q_0) = p_t(q_1 \rightarrow q_0) p(q_1) \label{eqn:detbal} \end{equation}\) where \(p_t\) represents the transition probability. Its meaning is precise and clear: at any time, the number of transition events from \(q_1\) to \(q_0\) should be the same of \(q_0\) to \(q_1\), thus the total distribution holds. After knowing this, we can see the sampling process as a chain of transitions: a particle in this system will transit all the time, and the time evolution can be viewed as ensembles. It’s interesting that in statistical physics we use ensemble average to substitude the time average, while now we do the opposite. Now one can create a transition probability: \(\begin{equation} p_t(q_0 \rightarrow q_1) = \left\{ \begin{aligned} &amp;1 &amp;p(q_0)&lt;p(q_1) \\ &amp;\frac{p(q_1)}{p(q_0)}\ \ &amp;p(q_0)&gt;p(q_1) \end{aligned} \right. \label{eqn:tranprob} \end{equation}\) It’s not hard to check this equation is consistent with equation \eqref{eqn:detbal}.</p> <p>Then one can imagine in a physical system, a particle \(q\) will go through a bunch of states: \(\begin{equation} {\rm State}_0 \rightarrow {\rm State}_1 \rightarrow {\rm State}_2\rightarrow ... \rightarrow {\rm State}_n \label{eqn:chain} \end{equation}\) And the distribution of all these \(n\) states follows the \(V(q)\).</p> <h3 id="a-quick-proof-of-detailed-balance-will-lead-to-vq">A quick proof of detailed balance will lead to \(V(q)\)</h3> <p>Imagine we have a two-level system, with only two possible states, let’s do this process for \(n\) times: suppose \(q_0\) has lower potential energy and we start from it. Then assume process \(q_0 \rightarrow q_1\) is tried \(x\) times, the backward process must happen \(x*p(q_1)/p(q_0)\) times. So among all the samples, we have \(x*p(q_1)/p(q_0)\) \(q_1\), and \(x\) \(q_0\), and you can see it perfectly recovers the distribution.</p> <p>– But in real problem we have infinite possible states! Does this relation still holds? Yes. Suppose we run a long chain as in \eqref{eqn:chain}, and it has come to a steady state, thus the distribution of particles \(\pi(q)\) won’t change overtime. Let’s cut the total chain into two parts: the first part is \({\rm State}_0,{\rm State}_2,{\rm State}_4,...\) and the second part is \({\rm State}_1,{\rm State}_3,{\rm State}_5,...\) and since it is long enough, we can imagine half of the total samples should also be in steady state, thus, the distribution \(\pi_1(q)\) and \(\pi_2(q)\) for both part should be the same, same as the total distribution, and more interestingly, the second part can be view as the acceptance result of part 1. So we can interpret these two parts as: first we have a sample (group 1), them we let all particles in this sample to do a transition (no matter successful or not), and we get the group 2.</p> <p>Then we just randomly choose a random position \(q_1\), in the sample, they appears \(n_1 = n*\pi(q_1)\) times. Then total successful transition from \(q_1\) to all other places is:</p> \[\begin{equation} n_{1,\rm out} = \int n*\pi(q_1)Q(q\vert q_1)p(q_1\rightarrow q) \ dq \end{equation}\] <p>Where \(Q(q_1\vert q)\) is the probability of proposing \(q_1\) as the next destination. Samely, successful transitions from all other places to \(q_1\) is: \(\begin{equation} n_{1,\rm in} = \int n*\pi(q)Q(q_1\vert q)p(q\rightarrow q_1)\ dq \end{equation}\)</p> <p>Then as we talked just now, a steady state means \(n_{1,\rm out} = n_{1,\rm in}\) at each location, thus we have:</p> \[\begin{equation} \int n*\pi(q_1)Q(q\vert q_1)p(q_1\rightarrow q) \ dq = \int n*\pi(q)Q(q_1\vert q)p(q\rightarrow q_1)\ dq \end{equation}\] <p>Differetiate both sides yield:</p> \[\begin{equation} \pi(q_1)Q(q\vert q_1)p(q_1\rightarrow q) = \pi(q)Q(q_1\vert q)p(q\rightarrow q_1) \end{equation}\] <p>Then we can see that if we just use a location proposal function \(Q\) that satifies \(Q(q\vert q_1)=Q(q_1\vert q)\), then the above equation comes to:</p> \[\begin{equation} \pi(q_1)p(q_1\rightarrow q) = \pi(q)p(q\rightarrow q_1) \end{equation}\] <p>Applied the equation \eqref{eqn:tranprob}, we can get:</p> \[\begin{equation} \pi(q_1)/p(q_1) = \pi(q)/p(q) \end{equation}\] <p>Since integration of \(\pi(q)\) and \(p(q)\) are all 1, one can find that \(\pi(q) = p(q)\) must hold. We’ve already know the desired distribution can be gained once the detailed balance is achieved, and we just proved that if we construct this chain follows the detailed balance rule, we will get the target distribution. I’ve forgotten how do we prove the equivalence between equilibrium state and detailed balance, but I guess it should be similar.</p> <p>So far so good? But the traditional MCMC have some problem, and I’ll talk about how do we deal with the problem with Hamitonian Monte-Carlo.</p> <h2 id="hamitonian-monte-carlo">Hamitonian Monte Carlo</h2> <p>The main setback of vanilla MCMC lies in the low acceptance ratio, espeially in high dimensional space. Let’s consider an example: imagine your proposal kernel \(Q\) will propose next position randomly inside a \(n-\)dimensional sphere, with radius \(R\), and the true probablity distribution is a also a sphere with radius \(R\): \(p(q) = const\) inside sphere and 0 otherwise. Now the starting point lies at the edge of this sphere.</p> <p>Then in \(1-\)D case, the probability of proposing a location inside this const prob sphere is simply 1/2. However in \(2-\)D case, this probability shrinks to \(\sim 0.35\); in \(3-\)D case, this probability shrinks to \(0.25\). Thus, If you’re working on high-dimensional parameter space, for example in LCDM we have 6 parameters, this method would be overwhelmingly inefficient, sometimes even fails: the states would be trapped in a small region, never seeing the whole distribution.</p> <p>Now we’re clear about the enemy – low acceptance ratio, which lead to biased result. Someone had a crazy idea about how to solve the problem: back to equation \eqref{eqn:tranprob}, the low ratio came from the low probability of finding a good target to get high \(p(q_1)/p(q_0)\). How to find a good target each time? How about making a chain with 100% acceptance probability?</p> <p>Then the problem becomes, is there anyway keeping the \(\exp^{-U(q)}\) the same after proposing a new location? I bet you think of one theory: <strong>Hamitonian Dynamics</strong>. So far we’ve been neglect the kinetic energy since we don’t want extra useless quantity, but soon we can prove it’s not useless, actually extremely helpful.</p> <p>If we introduce momentum \(p\) associated with \(q\), we can write down the full Hamitonian as \(H(p,q) = T + U = p^2/2m + U(q)\). Thus in this case, the equilibrium state follows \(p(p,q)\propto \exp^{-H(p,q)}\). Now the interesting thing happens, \(\exp^{-H(p,q)} =\exp^{-T(p)}\exp^{-U(q)}\), thus, if we integrate over all \(p\)s to get the marginalized distribution \(p(q)\), it’s still \(p(q)\propto \exp^{-U(q)}\). In this case, we can say that the \(p\) variable is totally irrelavent to \(q\) variable. So introducing this \(p\) didn’t change anything about \(q\), we just need to drop all the \(p\)s when summerizing our result.</p> <p>Now how do this new parameter change our life? The Hamitonian physics gives us one way of maintaining the \(H\) during finding locations. Following Haminotian equation, the \(H\) automatically conserves. More interestingly, we know the distribution of \(p\): in probability density, the relative part is \(e^{p^2/2m}\), this is exactly the form of Gaussian distribution, upto a adjustable parameter \(m\). Thus, we know very well how to sample \(p\). But how do this related with sampling \(q\)? One guy had a brilliant idea one day: instead of directly sampling a new \(p,q\) pair, we could just sample a new \(p\) according to Gaussian distribution and hold \(p\), and evolve the \(p,q\) with Hamitonian dynamics for a constant “time”. This looks nice, but how do we justify this follows the detailed balance? Here is a simple proof:</p> <p>Suppose our current state is in \(q_0\), target state is \(q_1\), eqn. \eqref{eqn:detbal} is \(\begin{equation} p_t(q_0 \rightarrow q_1) p(q_0) = p_t(q_1 \rightarrow q_0) p(q_1) \end{equation}\)</p> <p>Suppose there is one single \(p_0\) to satisfy that \(p_0,q_0\) goes to \(p_1,q_1\) after Hamitonian process. Then the LHS of eqn. \eqref{eqn:detbal} becomes: \(\begin{equation} p_t(q_0 \rightarrow q_1)p(q_0) = p(p_0)p(q_0) = e^{-p_0^2/2m-U(q_0)} \end{equation}\) Since we know the hamitonian process is invertible, i.e. if \(p_0,q_0\) goes to \(p_1,q_1\), then \(-p_1,q_1\) goes to \(-p_0,q_0\).The RHS becomes: \(\begin{equation} p_t(q_1 \rightarrow q_0)p(q_1) = p(-p_1)p(q_1) = e^{-p_1^2/2m-U(q_1)} \end{equation}\)</p> <p>Following Hamitonian conservation, we simply have \(e^{-p_1^2/2m-U(q_1)} = e^{-p_0^2/2m-U(q_0)}\), thus detailed balance still holds.</p> <p>If there’re more than one \(p_0\) that leads to \(q_1\), we can simply rewrite LHS as: \(\begin{equation} p_t(q_0 \rightarrow q_1)p(q_0) = (p(p_01)+p(p_03)+p(p_02)+...+p(p_0n))p(q_0) \end{equation}\)</p> <p>For every single \(p(p_0i)\), the detailed balance is valid as our derivation before, so the summation over all \(p_0s\) must follows detailed balance.</p> <p>For now we’ve finished explaining HMC, mainly on two aspects: why this is faster? because it proposes better new states. why it follows the detailed balance? Because this Hamitonian dynamics is invertible. So this is a much better method, in practice it can even sample ~10k dimensions of parameters. But what’s the price?</p> </div> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"dkn16/dkn16.github.io","data-repo-id":"R_kgDOJ3sY1A","data-category":"Announcements","data-category-id":"DIC_kwDOJ3sY1M4CZD_s","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Kangning Diao. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: January 19, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>